#+TITLE: Chapter 21: Market-Based Valuation

A major task in derivatives analytics is the market-based valuation of options and derivatives that are not liquidly traded. To this end, one generally calibrates a pricing model to market quotes of liquidly traded options and uses the calibrated model for the pricing of the non-traded options.

This chapter is divided into sections that implement the following major tasks:

Options Data
  We need the DAX 30 stock index itself and the European options on the index

Model Calibration
  To value the non-traded options in a market-consistent fashion, one generally first
  calibrates the chosen model to quoted option prices in such a way that the model based on the
  optimal parameters replicates the market prices as well as possible

Portfolio Valuation
  The final task is to model and value the non-traded options; important risk measures are also
  estimated on a position and portfolio level

* Options Data

#+begin_src python
dax = pd.read_csv('data/tr_eikon_option_data.csv')

for col in ['CF_DATE', 'EXPIR_DATE']:
    dax[col] = dax[col].apply(lambda date: pd.Timestamp(date))

dax.info()
dax.set_index('Instrument').head(7)

# assign the relevant index level to the initial_value var
initial_value = dax.iloc[0]['CF_CLOSE']

# seperate the options data for calls and puts
calls = dax[dax['PUTCALLIND'] == 'CALL'].copy()
puts = dax[dax['PUTCALLIND'] == 'PUT '].copy()

# market quotes and implied volatilities for European call options on the DAX 30
calls.set_index('STRIKE_PRC')[['CF_CLOSE', 'IMP_VOLT']].plot(secondary_y='IMP_VOLT',
                                                             style=['bo', 'rv'])
plt.show()

# market quotes and implied volatilities for European put options on the DAX 30
ax = puts.set_index('STRIKE_PRC')[['CF_CLOSE', 'IMP_VOLT']].plot(secondary_y='IMP_VOLT',
                                                             style=['bo', 'rv'])
ax.get_legend().set_bbox_to_anchor((0.25, 0.5))
plt.show()
#+end_src

* Model Calibration

This section selects the relevant market data, models the European options on the DAX30 index, and implements the calibration procedure itself.

#+begin_src python
# set limit value for the derivation of the strike price from the current index level
# (moneyness condition)
limit = 500

# selects, based on the limit value, the European call options to be included for the calibration
option_selection = calls[abs(calls['STRIKE_PRC'] - initial_value) < limit].copy()

option_selection.info()
option_selection.set_index('Instrument').tail()

# European call options on the DAX30 used for model calibration
option_selection.set_index('STRIKE_PRC')[['CF_CLOSE', 'IMP_VOLT']].plot(secondary_y='IMP_VOLT',
                                                                        style=['bo', 'rv'])
plt.show()
#+end_src

* Option Modeling

#+begin_src python
# create market environment
pricing_date = option_selection['CF_DATE'].max()
me_dax = MarketEnvironment('DAX30', pricing_date)
maturity = pd.Timestamp(calls.iloc[0]['EXPIR_DATE'])
me_dax.add_constant('initial_value', initial_value)
me_dax.add_constant('final_date', maturity)
me_dax.add_constant('currency', 'EUR')
me_dax.add_constant('frequency', 'B')
me_dax.add_constant('paths', 10000)
me_dax.add_curve('discount_curve', ConstantShortRate('csr', 0.01))

# add constants for the jump diffusion class
me_dax.add_constant('volatility', 0.2)
me_dax.add_constant('lambda', 0.8)
me_dax.add_constant('mu', -0.2)
me_dax.add_constant('delta', 0.1)

dax_model = JumpDiffusion('dax_model', me_dax)

# European call option

# set strike price and maturity
me_dax.add_constant('strike', initial_value)
me_dax.add_constant('maturity', maturity)

# payoff func for a European call option
payoff_func = 'np.maximum(maturity_value - strike, 0)'

dax_eur_call = ValuationMCSEuropean('dax_eur_call', dax_model, me_dax, payoff_func)
dax_eur_call.present_value()

# valuation objects can be defined for all relevant European call options on the DAX30 index.
options_models = {}
for option in option_selection.index:
    strike = option_selection['STRIKE_PRC'].loc[option]
    me_dax.add_constant('strike', strike)
    options_models[strike] = ValuationMCSEuropean(f'eur_call_{strike}',
                                                  dax_model,
                                                  me_dax,
                                                  payoff_func)

def calculate_model_values(p0):
    '''return all relevant option values'''
    volatility, lamb, mu, delta = p0
    dax_model.update(volatility=volatility,
                     lamb=lamb,
                     mu=mu,
                     delta=delta)
    return {strike: model.present_value(fixed_seed=True) for strike, model in options_models.items()}

calculate_model_values((0.1, 0.1, -0.4, 0.0))
#+end_src

* Calibration Procedure

Calibration of an option pricing model is, in general, a convex optimization problem.
The most widely used function for this is the /mean-squared error/ for the model option values given the market quotes of the options.



#+begin_src python

#+end_src
