#+TITLE: Chapter 12: Stochastics

This chapter introduces the following topics from a Python perspective:

- Random Numbers
- Simulation
- Valuation
  The 2 main disciplines when it comes to valuation are the valuation of derivatives with European exercise (at a specific date) and
  American exercise (over a specific time interval); there are also instruments with Bermudan exercise (exercise at a finite set of specific dates)
- Risk Measures
  Calculation of risk measures like value-at-risk, credit value-at-risk, and credit valuation adjustments

* Random Numbers

#+begin_src python
import math
import numpy as np
import numpy.random as npr
import matplotlib.pyplot as plt
plt.style.use('seaborn')
import matplotlib
matplotlib.use('tkAgg')

npr.seed(100)
np.set_printoptions(precision=4)

npr.rand(10)
npr.rand(5, 5)
npr.rand(10) * (10 - 5) + 10

sample_size = 500
rn1 = npr.rand(sample_size, 3)            # uniformly distributed random numbers
rn2 = npr.randint(0, 10, sample_size)     # random integers for a given interval
rn3 = npr.sample(size=sample_size)
a = [0, 25, 50, 75, 100]
rn4 = npr.choice(a, size=sample_size)     # randomly sampled values from a finite list object

fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(nrows=2, ncols=2)
ax1.hist(rn1, bins=25, stacked=True)
ax1.set_title('rand')
ax1.set_ylabel('frequency')
ax2.hist(rn2, bins=25)
ax2.set_title('randint')
ax3.hist(rn3, bins=25)
ax3.set_title('sample')
ax3.set_ylabel('frequency')
ax4.hist(rn4, bins=25)
ax4.set_title('choice')
plt.show()
#+end_src

* Simulation

Consider the Black-Scholes-Merton setup for option pricing. In their setup, the level of a stock index S_t at a future date T given a level S0 as of today is given according to

S_T = S_0 \exp{((r - \frac{1}{2} \sigma_2) T + \sigma \sqrt{T} z)}

where
- S_T is the index level at date T
- r is the constant riskless short rate
- \sigma is the constant volatility (= standard deviation of returns) of S
- z is the standard normally distributed random variable


#+begin_src python
S0 = 100
r = 0.05
sigma = 0.25
T = 2.0
I = 10000
ST1 = S0 * np.exp((r - 0.5 * sigma ** 2) * T + sigma * math.sqrt(T) * npr.standard_normal(I))

plt.figure()
plt.hist(ST1, bins=50)
plt.xlabel('index level')
plt.ylabel('frequency')
plt.show()

# we could also try lognormal to take into account the right leaning distribution
ST2 = S0 * npr.lognormal((r - 0.5 * sigma ** 2) * T,
                         sigma * math.sqrt(T), size = I)

plt.figure()
plt.hist(ST2, bins=50)
plt.xlabel('index level')
plt.ylabel('frequency')
plt.show()

import scipy.stats as scs

scs.describe(ST1)
scs.describe(ST2)
#+end_src

* Stochastic Processes

#+begin_src python

#+end_src
